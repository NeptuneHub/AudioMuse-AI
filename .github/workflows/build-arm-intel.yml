# This workflow builds and pushes a multi-architecture Docker image for both AMD64 and ARM64.
# Each architecture is built NATIVELY on its own runner (no QEMU emulation) to avoid
# "Illegal instruction" crashes caused by QEMU-compiled binaries on real ARM hardware.
# After both builds complete, a manifest is created to combine them into a single multi-arch tag.
#
# Tags are automatically generated based on the triggering event:
# - devel branch -> 'devel'
# - mulan branch -> 'mulan'
# - version tags (e.g., v1.2.3) -> 'latest' + version number (e.g., '1.2.3')

name: Build, Test, and Push AudioMuse AI Docker Image INTEL and ARM

on:
  push:
    # We avoid triggering this workflow on direct pushes to `main` to prevent
    # accidental builds from routine commits. Keep `devel` and `mulan` as before.
    branches:
      - devel         # Trigger for 'devel' tag
      - mulan         # New branch also triggers for 'mulan' tag
    tags:
      - 'v*.*.*'      # Trigger for version tags like v1.0.0
  # Allow manual runs for debugging or manual pushes
  workflow_dispatch:

# Prevent concurrent builds for the same branch/tag — a new push cancels the in-progress build.
# This avoids race conditions where two builds overwrite each other's temporary tags.
concurrency:
  group: build-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io

jobs:
  # ============================================================================
  # Step 1: Compute image name and tags once (shared by all jobs)
  # ============================================================================
  prepare:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.repo_name.outputs.image }}
      tags: ${{ steps.tags.outputs.tags }}
      suffix: ${{ steps.tags.outputs.suffix }}
    steps:
      - name: Set lower-case image name
        id: repo_name
        run: echo "image=ghcr.io/$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Compute tags
        id: tags
        run: |
          TAGS=""
          SUFFIX=""
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION="${{ github.ref_name }}"
            VERSION="${VERSION#v}"
            TAGS="latest ${VERSION}"
            SUFFIX="release"
          elif [[ "${{ github.ref }}" == refs/heads/devel ]]; then
            TAGS="devel"
            SUFFIX="devel"
          elif [[ "${{ github.ref }}" == refs/heads/mulan ]]; then
            TAGS="mulan"
            SUFFIX="mulan"
          fi
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "suffix=${SUFFIX}" >> $GITHUB_OUTPUT
          echo "Tags to build: ${TAGS} (suffix: ${SUFFIX})"

  # ============================================================================
  # Step 2: Build each architecture NATIVELY (no QEMU)
  # ============================================================================
  build-amd64:
    needs: prepare
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Free Disk Space
        uses: jlumbroso/free-disk-space@main
        with:
          swap-storage: false
          large-packages: true
          tool-cache: true
          android: true
          dotnet: true
          haskell: true
          docker-images: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push AMD64 image
        uses: docker/build-push-action@v5
        with:
          context: ${{ github.workspace }}
          file: Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ needs.prepare.outputs.image }}:build-amd64-${{ needs.prepare.outputs.suffix }}
          cache-from: type=gha,scope=amd64-${{ github.ref_name }}
          cache-to: type=gha,scope=amd64-${{ github.ref_name }},mode=max

  build-arm64:
    needs: prepare
    runs-on: ubuntu-24.04-arm  # Native ARM64 runner — no QEMU emulation
    permissions:
      contents: read
      packages: write
    steps:
      - name: Free Disk Space
        uses: jlumbroso/free-disk-space@main
        with:
          swap-storage: false
          large-packages: true
          tool-cache: true
          android: true
          dotnet: true
          haskell: true
          docker-images: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push ARM64 image
        uses: docker/build-push-action@v5
        with:
          context: ${{ github.workspace }}
          file: Dockerfile
          platforms: linux/arm64
          push: true
          tags: ${{ needs.prepare.outputs.image }}:build-arm64-${{ needs.prepare.outputs.suffix }}
          cache-from: type=gha,scope=arm64-${{ github.ref_name }}
          cache-to: type=gha,scope=arm64-${{ github.ref_name }},mode=max

  # ============================================================================
  # Step 3: Merge into a single multi-arch manifest
  # ============================================================================
  merge-manifest:
    needs: [prepare, build-amd64, build-arm64]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch manifest
        run: |
          IMAGE="${{ needs.prepare.outputs.image }}"
          TAGS="${{ needs.prepare.outputs.tags }}"
          AMD64="${IMAGE}:build-amd64-${{ needs.prepare.outputs.suffix }}"
          ARM64="${IMAGE}:build-arm64-${{ needs.prepare.outputs.suffix }}"

          for TAG in $TAGS; do
            echo "Creating manifest for ${IMAGE}:${TAG}..."
            docker buildx imagetools create \
              --tag "${IMAGE}:${TAG}" \
              "${AMD64}" \
              "${ARM64}"
            echo "✓ Pushed ${IMAGE}:${TAG}"
          done

      - name: Verify multi-arch manifest
        run: |
          IMAGE="${{ needs.prepare.outputs.image }}"
          TAGS="${{ needs.prepare.outputs.tags }}"
          for TAG in $TAGS; do
            echo "=== Inspecting ${IMAGE}:${TAG} ==="
            docker buildx imagetools inspect "${IMAGE}:${TAG}"
          done

  # NOTE: Temporary per-arch tags (build-amd64-*, build-arm64-*) are left in the registry.
  # They get overwritten on every build, so at most 2 stale tags exist at any time.
  # Delete them manually from the GitHub Packages UI if desired.
