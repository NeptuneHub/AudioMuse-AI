# This workflow builds and tests a multi-architecture Docker image for both AMD64 and ARM64.
# It triggers on pushes to the main, devel, and onnx branches, as well as on version tags.
# Tags are automatically generated based on the triggering event:
# - main branch -> 'latest'
# - devel branch -> 'devel'
# - onnx branch -> 'onnx'
# - version tags (e.g., v1.2.3) -> version number (e.g., '1.2.3')

name: Build, Test, and Push AudioMuse AI Docker Image INTEL and ARM

on:
  push:
    branches:
      - main          # Trigger for 'latest' tag
      - devel         # Trigger for 'devel' tag
      - onnx          # New branch also triggers for 'onnx' tag
    tags:
      - 'v*.*.*'      # Trigger for version tags like v1.0.0

jobs:
  build-test-and-push:
    runs-on: ubuntu-latest # Run on a single AMD64 runner

    permissions:
      contents: read   # Allow checkout to read repository contents
      packages: write  # Allow pushing packages to GitHub Container Registry

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        # QEMU is used for cross-platform builds (e.g., building ARM on an x86 runner)
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        # Buildx is a Docker CLI plugin that extends the docker command with the full support of the features provided by Moby BuildKit.
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container
          driver-opts: image=moby/buildkit:latest

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # This new step uses a shell command to reliably convert the repository name to lower case.
      - name: Set lower-case repository name
        id: repo_name
        run: echo "name=$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      # This step uses the lower-case name from the previous step to generate tags.
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.repo_name.outputs.name }}
          tags: |
            # Set 'latest' tag for the main branch
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            # Set 'devel' tag only for the devel branch
            type=raw,value=devel,enable=${{ github.ref == 'refs/heads/devel' }}
            # Set 'onnx' tag only for the onnx branch
            type=raw,value=onnx,enable=${{ github.ref == 'refs/heads/onnx' }}
            # Use the version number for Git tags (e.g., v1.2.3 -> 1.2.3)
            type=semver,pattern={{version}}

      - name: Build and push AudioMuse AI Image
        id: docker_build_and_push
        uses: docker/build-push-action@v5
        with:
          context: ${{ github.workspace }}
          file: Dockerfile
          platforms: linux/amd64,linux/arm64 # Build for both Intel and ARM
          push: true
          tags: ${{ steps.meta.outputs.tags }}      # Use tags generated by the metadata-action
          labels: ${{ steps.meta.outputs.labels }}  # Add labels generated by the metadata-action
          cache-from: type=gha,scope=${{ github.ref_name }}
          cache-to: type=gha,scope=${{ github.ref_name }},mode=max

      # The following health check steps remain largely the same, but they now use the primary tag generated.
      # Note: We select the first tag from the list generated by the metadata action for the health check.
      - name: Run Flask App Container Health Check (AMD64)
        run: |
          IMAGE_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n 1)
          echo "Testing image: $IMAGE_TAG"

          echo "Starting temporary PostgreSQL container for Flask test (AMD64)..."
          docker run -d --name postgres-flask-test-amd64 \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            postgres:latest

          echo "Waiting for PostgreSQL (Flask test AMD64) to start..."
          for i in $(seq 1 30); do
            if docker exec postgres-flask-test-amd64 pg_isready -U testuser -d testdb -q; then
              echo "PostgreSQL (Flask test AMD64) is ready."
              break
            fi
            echo "Waiting for PostgreSQL (Flask test AMD64)... ($i/30)"
            sleep 2
            if [ $i -eq 30 ]; then
              echo "PostgreSQL (Flask test AMD64) did not become ready in time."
              docker logs postgres-flask-test-amd64
              exit 1
            fi
          done

          echo "Starting Flask app container for health check (AMD64)..."
          docker run -d --name flask-test-app-amd64 -p 8000:8000 \
            --link postgres-flask-test-amd64:postgres \
            -e SERVICE_TYPE=flask \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            -e POSTGRES_HOST=postgres \
            -e POSTGRES_PORT=5432 \
            $IMAGE_TAG

          echo "Waiting for Flask app (AMD64) to start (max 60 seconds)..."
          for i in $(seq 1 60); do
            if curl -sf -I http://localhost:8000/api/last_task | grep -qE "HTTP/[12](.[01])? (2|3)[0-9]{2}"; then
              echo "Flask app (AMD64) is up and responsive!"
              exit 0
            fi
            echo "Waiting... ($i/60)"
            sleep 1
          done
          echo "Flask app (AMD64) did not start or respond with a successful status on /api/last_task within the expected time."
          docker logs flask-test-app-amd64
          exit 1

      - name: Run RQ Worker Container Health Check (AMD64)
        run: |
          IMAGE_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n 1)
          echo "Testing image: $IMAGE_TAG"

          echo "Starting temporary Redis container for RQ worker (AMD64)..."
          docker run -d --name redis-test-amd64 redis:latest

          echo "Waiting for Redis (AMD64) to start..."
          for i in $(seq 1 30); do
            if docker exec redis-test-amd64 redis-cli ping | grep -q PONG; then
              echo "Redis (AMD64) is ready."
              break
            fi
            echo "Waiting for Redis (AMD64)... ($i/30)"
            sleep 1
            if [ $i -eq 30 ]; then
              echo "Redis (AMD64) did not become ready in time."
              docker logs redis-test-amd64
              exit 1
            fi
          done

          echo "Starting temporary PostgreSQL container for RQ worker test (AMD64)..."
          docker run -d --name postgres-rq-test-amd64 \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            postgres:latest

          echo "Waiting for PostgreSQL (RQ worker test AMD64) to start..."
          for i in $(seq 1 30); do
            if docker exec postgres-rq-test-amd64 pg_isready -U testuser -d testdb -q; then
              echo "PostgreSQL (RQ worker test AMD64) is ready."
              break
            fi
            echo "Waiting for PostgreSQL (RQ worker test AMD64)... ($i/30)"
            sleep 2
            if [ $i -eq 30 ]; then
              echo "PostgreSQL (RQ worker test AMD64) did not become ready in time."
              docker logs postgres-rq-test-amd64
              exit 1
            fi
          done

          echo "Starting RQ worker container for health check (AMD64)..."
          docker run -d --name rq-test-worker-amd64 \
            --link redis-test-amd64:redis --link postgres-rq-test-amd64:postgres \
            -e SERVICE_TYPE=worker \
            -e REDIS_URL=redis://redis:6379/0 \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            -e POSTGRES_HOST=postgres \
            -e POSTGRES_PORT=5432 \
            $IMAGE_TAG

          echo "Waiting for RQ worker (AMD64) to start (max 90 seconds)..."
          for i in $(seq 1 30); do
            if docker ps -f name=rq-test-worker-amd64 --format '{{.Status}}' | grep -q 'Up'; then
              sleep 2
              if docker logs rq-test-worker-amd64 2>&1 | grep -E "Listening on|RQ Worker [^ ]+ started"; then
                  echo "RQ worker container (AMD64) is running and listening."
                  exit 0
              fi
            fi
            echo "Waiting... ($i/30)"
            sleep 3
          done
          echo "RQ worker container (AMD64) did not start or become ready within the expected time."
          docker logs rq-test-worker-amd64
          exit 1

      - name: Clean up Docker containers
        if: always() # Run this step even if previous steps fail
        run: |
          echo "Cleaning up temporary Docker containers..."
          # Clean up Flask test containers
          docker rm -f flask-test-app-amd64 || true
          docker rm -f postgres-flask-test-amd64 || true
          # Clean up RQ worker test containers
          docker rm -f rq-test-worker-amd64 || true
          docker rm -f redis-test-amd64 || true
          docker rm -f postgres-rq-test-amd64 || true
          # The multi-arch image is only in the buildx cache and pushed to the registry,
          # so a simple 'docker rmi' on the host runner is not necessary.
