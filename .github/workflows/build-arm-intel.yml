# This workflow builds and pushes a multi-architecture Docker image for both AMD64 and ARM64.
# Each architecture is built NATIVELY on its own runner (no QEMU emulation) to avoid
# "Illegal instruction" crashes caused by QEMU-compiled binaries on real ARM hardware.
# After both builds complete, a manifest is created to combine them into a single multi-arch tag.
#
# Tags are automatically generated based on the triggering event:
# - devel branch -> 'devel'
# - mulan branch -> 'mulan'
# - version tags (e.g., v1.2.3) -> 'latest' + version number (e.g., '1.2.3')

name: Build, Test, and Push AudioMuse AI Docker Image INTEL and ARM

on:
  push:
    # We avoid triggering this workflow on direct pushes to `main` to prevent
    # accidental builds from routine commits. Keep `devel` and `mulan` as before.
    branches:
      - devel         # Trigger for 'devel' tag
      - mulan         # New branch also triggers for 'mulan' tag
    tags:
      - 'v*.*.*'      # Trigger for version tags like v1.0.0
  # Allow manual runs for debugging or manual pushes
  workflow_dispatch:

env:
  REGISTRY: ghcr.io

jobs:
  # ============================================================================
  # Step 1: Compute image name and tags once (shared by all jobs)
  # ============================================================================
  prepare:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.repo_name.outputs.image }}
      tags: ${{ steps.tags.outputs.tags }}
    steps:
      - name: Set lower-case image name
        id: repo_name
        run: echo "image=ghcr.io/$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Compute tags
        id: tags
        run: |
          TAGS=""
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION="${{ github.ref_name }}"
            VERSION="${VERSION#v}"
            TAGS="latest ${VERSION}"
          elif [[ "${{ github.ref }}" == refs/heads/devel ]]; then
            TAGS="devel"
          elif [[ "${{ github.ref }}" == refs/heads/mulan ]]; then
            TAGS="mulan"
          fi
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "Tags to build: ${TAGS}"

  # ============================================================================
  # Step 2: Build each architecture NATIVELY (no QEMU)
  # ============================================================================
  build-amd64:
    needs: prepare
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Free Disk Space
        uses: jlumbroso/free-disk-space@main
        with:
          swap-storage: false
          large-packages: true
          tool-cache: true
          android: true
          dotnet: true
          haskell: true
          docker-images: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push AMD64 image
        uses: docker/build-push-action@v5
        with:
          context: ${{ github.workspace }}
          file: Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ needs.prepare.outputs.image }}:build-amd64-${{ github.sha }}
          cache-from: type=gha,scope=amd64-${{ github.ref_name }}
          cache-to: type=gha,scope=amd64-${{ github.ref_name }},mode=max

  build-arm64:
    needs: prepare
    runs-on: ubuntu-24.04-arm  # Native ARM64 runner — no QEMU emulation
    permissions:
      contents: read
      packages: write
    steps:
      - name: Free Disk Space
        uses: jlumbroso/free-disk-space@main
        with:
          swap-storage: false
          large-packages: true
          tool-cache: true
          android: true
          dotnet: true
          haskell: true
          docker-images: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push ARM64 image
        uses: docker/build-push-action@v5
        with:
          context: ${{ github.workspace }}
          file: Dockerfile
          platforms: linux/arm64
          push: true
          tags: ${{ needs.prepare.outputs.image }}:build-arm64-${{ github.sha }}
          cache-from: type=gha,scope=arm64-${{ github.ref_name }}
          cache-to: type=gha,scope=arm64-${{ github.ref_name }},mode=max

  # ============================================================================
  # Step 3: Merge into a single multi-arch manifest
  # ============================================================================
  merge-manifest:
    needs: [prepare, build-amd64, build-arm64]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch manifest
        run: |
          IMAGE="${{ needs.prepare.outputs.image }}"
          TAGS="${{ needs.prepare.outputs.tags }}"
          AMD64="${IMAGE}:build-amd64-${{ github.sha }}"
          ARM64="${IMAGE}:build-arm64-${{ github.sha }}"

          for TAG in $TAGS; do
            echo "Creating manifest for ${IMAGE}:${TAG}..."
            docker buildx imagetools create \
              --tag "${IMAGE}:${TAG}" \
              "${AMD64}" \
              "${ARM64}"
            echo "✓ Pushed ${IMAGE}:${TAG}"
          done

      - name: Verify multi-arch manifest
        run: |
          IMAGE="${{ needs.prepare.outputs.image }}"
          TAGS="${{ needs.prepare.outputs.tags }}"
          for TAG in $TAGS; do
            echo "=== Inspecting ${IMAGE}:${TAG} ==="
            docker buildx imagetools inspect "${IMAGE}:${TAG}"
          done

  # ============================================================================
  # Step 4: Clean up temporary per-arch tags
  # ============================================================================
  cleanup:
    needs: [prepare, merge-manifest]
    runs-on: ubuntu-latest
    if: always() && needs.merge-manifest.result == 'success'
    permissions:
      packages: write
    steps:
      - name: Delete temporary per-arch tags
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          IMAGE="${{ needs.prepare.outputs.image }}"
          # Extract org/repo and package name from ghcr.io/org/repo format
          ORG_REPO="${IMAGE#ghcr.io/}"
          ORG="$(echo "$ORG_REPO" | cut -d/ -f1)"
          PKG="$(echo "$ORG_REPO" | cut -d/ -f2)"

          for ARCH in amd64 arm64; do
            TAG="build-${ARCH}-${{ github.sha }}"
            echo "Deleting temporary tag: ${TAG}..."

            # Find the version ID for this tag
            VERSION_ID=$(curl -s -H "Authorization: Bearer ${GH_TOKEN}" \
              "https://api.github.com/orgs/${ORG}/packages/container/${PKG}/versions" \
              | python3 -c "
          import sys, json
          versions = json.load(sys.stdin)
          for v in versions:
              tags = v.get('metadata', {}).get('container', {}).get('tags', [])
              if '${TAG}' in tags:
                  print(v['id'])
                  break
          " 2>/dev/null || echo "")

            if [ -n "$VERSION_ID" ]; then
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
                -H "Authorization: Bearer ${GH_TOKEN}" \
                "https://api.github.com/orgs/${ORG}/packages/container/${PKG}/versions/${VERSION_ID}")
              if [ "$HTTP_CODE" = "204" ]; then
                echo "✓ Deleted ${TAG} (version ${VERSION_ID})"
              else
                echo "⚠ Failed to delete ${TAG} (HTTP ${HTTP_CODE}) — may need manual cleanup"
              fi
            else
              echo "⚠ Tag ${TAG} not found — may already be cleaned up"
            fi
          done
